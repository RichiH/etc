#!/usr/bin/env python

'''Script to translate rst into HTML and post it to a Wordpress server.

This script also has some nice features:

- image:: directives upload images using the WordPress API and point
  at the uploaded URL. If the image is non-local, it will be downloaded using
  urllib and deleted after it's been uploaded.
- categories are read from bibliographic fields at the top of the file.
- an id: field is saved at the top of the file, as well as in a dotrc
  file in ~/.config (or as specified by xdg), and if an id is known
  for a post, that post is edited (instead of a new one being created)

Getting started
===============

Just run the script once to create ~/.config/rst2wp/wordpressrc.
Account settings and configuration stuff goes in there.

Usage
=====

Run rst2wp with the name of a post as its argument. The post is just
an ordinary RST file, except that the (normally optional)
bibliographic fields at the top of the file are required in order to
provide a title to the post.

Here's a sample post::

    :title: This is a brand new test!

    This is just a test, of course. Here's an image:

    |my_image|

    I'd like to close with a quote:

        Four score and seven years ago..


    .. |my_image| image:: http://travelogue.betacantrips.com/wp-content/uploads/2009/09/tumblr_kqlgm7DjDq1qz59y9o1_500.gif
       :target: http://travelogue.betacantrips.com/

Once you run rst2wp on this file, the file will be modified. Particularly,
you'll see::

    :id: 362

in the bibliographic fields at the top, and in the `image::` directive, you'll see::

    :saved_as: http://travelogue.betacantrips.com/wp-content/uploads/2009/09/tumblr_kqlgm7DjDq1qz59y9o1_500.gif

In the future, this blog post will be altered instead of new ones
being uploaded, and the uploaded image won't be re-uploaded.

You might find this annoying because you might have to re-load the
file in your text editor, so this information is also saved in
~/.config/rst2wp. You can choose one or the other by editing
config.data_storage.
'''
# FIXME: robust against missing configuration keys
# FIXME: prompt for a good filename/extension for unknown weird files
# FIXME: could use fields['date'] for publish date

# Configuration:
# - config.data_storage = one of "file", "dotrc", or "both".
#   "dotrc" means to store URLs of uploaded images in ~/.config/rst2wp/images
#   and ids of posts in ~/.config/rst2wp/posts. "file" means to store that
#   information in the .rst file itself. "both" stores in both places,
#   and generally trusts the file over the dotrc files.
#
# N.B.: if config.data_storage = "dotrc", the filename of the post is
# assumed to be unique across all blog posts. This means if you re-use
# a filename, you could potentially edit an existing blog-post. To
# help guard against this, FIXME: need to check if title is the same
# as what's in the dotrc, and if different, confirm

import re
import getopt
from xdg import BaseDirectory
import ConfigParser
import sys
import os.path
import tempfile, subprocess, time
from docutils import core, io, nodes, utils
from docutils.parsers.rst import roles, directives, languages
import docutils.parsers.rst.directives.images
from docutils.readers import standalone
import docutils.transforms
import yaml
import urllib

sys.path.insert(0, os.path.join(os.path.abspath(os.path.dirname(__file__)), "lib"))

TEMP_DIRECTORY = '/tmp'

import wordpresslib

class UsageError(Exception):
    @classmethod
    def usage_message(cls):
        return \
'''Usage: {name} filename
Converts an RST file into HTML and posts it to Wordpress.'''.format(name=os.path.basename(sys.argv[0]))

    def error_message(self):
        return "{error}\nSee '{path} --help'.".format(error=self.args[0],
                                                      path=self.args[1])

class MyImageDirective(directives.images.Image):
    option_spec = directives.images.Image.option_spec.copy()
    option_spec.update({'saved_as': directives.unchanged})

    def run(self):
        uri = directives.uri(self.arguments[0])
        print 'Handling image directive:', uri
        document = self.state_machine.document
        app = document.settings.application

        if 'saved_as' in self.options or app.has_info(document, 'image '+uri, 'new uri', location=IMAGES_LOCATION):
            document.settings.used_images[uri] = True
            if 'saved_as' in self.options:
                real_uri = self.options['saved_as']
            else:
                real_uri = app.get_info(document, 'image ' + uri, 'new uri', location=IMAGES_LOCATION)
            print "Using saved location for image:", real_uri

            self.arguments[0] = real_uri
            result_nodes = directives.images.Image.run(self)

        else:
            # Call the super here to update options, etc.
            result_nodes = directives.images.Image.run(self)

            # Use a pending to do stuff here -- download after all the
            # checking is done
            pending = nodes.pending(DownloadImageTransform, rawsource=self.block_text)
            pending.details.update(self.options)
            document.note_pending(pending)

            # This could be any inline element, but we use the image we'd
            # normally have to look coherent.
            last_node = result_nodes[-1]
            if isinstance(last_node, nodes.reference):
                last_node = last_node.children[0]

            # Embed the pending in the image node
            last_node += pending

        return result_nodes

directives.register_directive('image', MyImageDirective)

class DownloadImageTransform(docutils.transforms.Transform):
    default_priority = 100
    def apply(self, **kwargs):
        if self.document.settings.application.preview:
            print "Not downloading image because we're previewing document"
            if self.startnode:
                self.startnode.remove_self()

            return

        print "replacing image with a downloaded verison"
        contents = self.build_downloaded_node()

        if self.startnode.parent:
            self.startnode.parent.replace_self(contents)

    def build_downloaded_node(self):
        # FIXME: disabling for now
        #return nodes.image(uri=self.startnode.details['uri'])

        filename = uri = self.startnode.details['uri']

        app = self.document.settings.application

        self.upload_image(uri)

        new_uri = app.get_info(self.document, 'image ' + uri, 'new uri', location=IMAGES_LOCATION)
        self.document.settings.used_images[uri] = True

        image = nodes.image(uri=new_uri)
        return image


    def upload_image(self, uri):
        # FIXME: this might not work on non-Unix -- but who cares?
        target_filename = os.path.split(uri)[1]
        if '.' not in target_filename:
            raise TypeError, 'FIXME: prompt for a filename for %s'%(target_filename,)
        #print "returned:", filename, headers

        filename, headers = urllib.urlretrieve(uri, os.path.join(TEMP_DIRECTORY, target_filename))
        wp = self.document.settings.wordpress_instance

        print 'uploading file', uri
        new_uri = wp.upload_file(filename, overwrite=True)

        if filename.startswith(TEMP_DIRECTORY):
            # FIXME?
            os.unlink(filename)

        app = self.document.settings.application
        app.save_info(self.document, 'image '+ uri, 'new uri', new_uri, IMAGES_LOCATION, image=uri)

class BibliographicTransform(docutils.transforms.Transform):
    '''Parses the crap out of the bibliographic fields in the document
    and sticks them in document.settings.bibliographic_fields.'''
    default_priority = 98
    def __init__(self, *args, **kwargs):
        docutils.transforms.Transform.__init__(self, *args, **kwargs)

    def apply(self, **kwargs):
        header = self.document[0]
        if isinstance(header, nodes.field_list):
            fields = self.get_header_as_dict(header)
        else:
            fields = {}
        self.document.settings.bibliographic_fields = fields

    def get_header_as_dict(self, header):
        fields = {}
        for field in header.children:
            field_name, field_body = field.children

            # field_name is a node with a Text child
            assert len(field_name.children) == 1, "don't know how to handle"
            assert isinstance(field_name.children[0], nodes.Text)
            key = field_name.children[0].astext()

            # field_body is a node with either a bulleted_list child, or
            # a single Text child, or..?
            if len(field_body.children) == 0:
                fields[key] = None
                continue

            assert len(field_body.children) == 1, "don't know how to handle"
            data = field_body.children[0]
            if isinstance(data, nodes.bullet_list):
                value = [node.astext() for node in data.children]
            elif isinstance(data, nodes.Text):
                value = data.astext()
            elif isinstance(data, nodes.paragraph):
                value = data.children[0].astext()
            else:
                raise TypeError, "don't know how to handle a %s in the header %s"%(
                    data.__class__, key)
            fields[key] = value

        return fields

class ValidityCheckerTransform(docutils.transforms.Transform):
    default_priority = 99
    def apply(self):
        fields = self.document.settings.bibliographic_fields
        app = self.document.settings.application

        def _no_field(msg, msg2=''):
            if msg2: msg = msg+msg2
            raise TypeError, msg

        if 'title' not in fields:
            _no_field("title missing", """
- Make sure you have a bibliographic field list at the top of your file.
- Make sure that a title field is included.""")

        if 'category' in fields:
            fields['categories'] = fields.pop('category')

        if not fields.get('categories') and \
                not app.config.has_option('config', 'default_category'):
            _no_field("No categories supplied", """
WordPress requires at least one category.

If you don't want to categorize this post, use the "Uncategorized" category.

Set config.default_category to do this automatically.

:categories: Uncategorized
""")

        categories = fields.get('categories') or fields.get('category')
        if categories == None:
            fields['categories'] = categories = [app.config.get('config', 'default_category')]

        wp = self.document.settings.wordpress_instance
        for cat in categories:
            self.check_existing_category(wp, cat)

        if 'tag' in fields:
            fields['tags'] = fields.pop('tag')

        if 'tags' in fields:
            for tag in fields['tags']:
                self.check_existing_tag(wp, tag)

    def check_existing_tag(self, wp, tag):
        if not wp.has_tag(tag):
            tag = self.read_tag(tag)

    def check_existing_category(self, wp, cat):
        if not wp.has_category(cat):
            cat = self.read_category(cat)

    def read_base(self, name):
        fmt = {'name': repr(str(name))}
        slug = raw_input("Slug for {name} [auto-generate]: ".format(**fmt))
        description = raw_input("Description for {name} [none]: ".format(**fmt))
        return {'slug': slug, 'description': description, 'name': name}

    def read_tag(self, tag):
        fmt = {'tag': repr(str(tag))}
        if ',' in tag:
            raise ValueError, """Cannot create tag with ',' in the name.

If you really want a tag with a comma in the name, create it via the web interface first."""

        print "Post has non-existent tag {tag}. Ctrl-C to cancel.".format(**fmt)
        print "rst2wp can create the tag automatically, but can't set description or slug via XML-RPC API. If you want to edit these things, log in to the blog!"
        raw_input("Confirm creation? [yes]")

    def read_category(self, cat):
        fmt = {'category': repr(str(cat))}
        print "Post has non-existent category {category}. Ctrl-C to cancel.".format(**fmt)
        raw_input("Confirm? [yes]")

        data = self.read_base(cat)
        parent_id = raw_input("Parent id for {category} [none]: ".format(**fmt))
            
        c = wordpresslib.WordPressCategory(parent_id=parent_id, **data)
        wp.new_category(c)


class WordPressReader(standalone.Reader):
    def __init__(self, preview=False):
        standalone.Reader.__init__(self)
        self.preview = preview

    def get_transforms(self):
        transforms = standalone.Reader.get_transforms(self)
        if self.preview: return transforms

        transforms.insert(0, BibliographicTransform)
        transforms.insert(1, ValidityCheckerTransform)
        return transforms


class Application(object):
    def __init__(self):
        super(Application, self).__init__()
        self._config = None
        self.preview = False

    @property
    def config(self):
        if self._config: return self._config
        return self._load_config()

    def _load_config(self):
        config = ConfigParser.SafeConfigParser()
        self.VERBOSE = False

        for dir in BaseDirectory.load_config_paths('rst2wp'):
            filename = os.path.join(dir, 'wordpressrc')
            if not os.path.exists(filename): continue
            print "loading config from", filename
            with file(filename) as f:
                config.readfp(f)
            print 'config loaded'

        DEFAULT_WORDPRESS_URL = 'http://wordpress.example.com/wordpress/xmlrpc.php'

        if not config.has_section('account'):
            config.add_section('account')
            # Fill in some default values
            config.set('account', 'url', DEFAULT_WORDPRESS_URL)
            config.set('account', 'username', 'joe_user')
            config.set('account', 'password', 'trustNo1')

            config.set('config', 'data_storage', 'both')

            path = os.path.join(BaseDirectory.save_config_path('rst2wp'), 'wordpressrc')
            print 'Need configuration! Edit %s'%(path,)
            with file(path, 'wb') as fp:
                config.write(fp)
            sys.exit()

        if config.get('account', 'url') == DEFAULT_WORDPRESS_URL:
            # Don't wipe out what they might have configured
            print 'Still needs configuration! Edit %s'%(path,)
            sys.exit()

        self._config = config
        return config

    def search_configs(self, configfile, section, key, default=None):
        '''Looks through all configs named configfile for (section, key)'''
        for dir in BaseDirectory.load_config_paths('rst2wp'):
            filename = os.path.join(dir, configfile)
            if not os.path.exists(filename): continue

            config = ConfigParser.SafeConfigParser()
            with file(filename) as f:
                config.readfp(f)
            if not config.has_section(section): continue

            if not config.has_option(section, key): continue

            return config.get(section, key)

        return default


class Rst2Wp(Application):
    @property
    def data_storage(self):
        return self.config.get('config', 'data_storage')

    def parse_args(self, args):
        filename = None
        opts, leftover = getopt.gnu_getopt(args[1:], 'p', ['preview'])
        for opt, val in opts:
            if opt in ['-p', '--preview']:
                self.preview = True

        if len(leftover) > 0:
            filename = leftover[0]
        if filename == None:
            raise UsageError, ("%s needs a filename."%(args[0],), args[0])

        self.filename = filename

    def prompt(self, msg):
        return raw_input(msg)

    def save_info(self, document, section, key, value, location=None,
                  # FIXME: fugly hack
                  image=None):
        "Usage: app.save_info(document, 'post ' + filename, 'id', '365')"
        location = location or POSTS_LOCATION
        data_storage = self.data_storage
        if data_storage in ['both', 'dotrc']:
            config = ConfigParser.SafeConfigParser()
            filename = location(self)
            if os.path.exists(filename):
                with file(filename) as f:
                    config.readfp(f)

            if not config.has_section(section):
                config.add_section(section)

            config.set(section, key, value)
            with file(filename, 'wb') as fp:
                config.write(fp)

        if data_storage in ['both', 'file']:
            if location == POSTS_LOCATION:
                self.replace_field(document, key, value)
            elif location == IMAGES_LOCATION:
                if image:
                    self.replace_image(document, image, value)
                    # But since that won't hit the disk until after the post,
                    # let's stick it in document.settings too
                    if not hasattr(document.settings, 'image_uris'):
                        document.settings.image_uris = {}
                    document.settings.image_uris[key] = value
            else:
                raise ValueError, "couldn't save data in {location}".format(location=location)

    def get_info(self, document, section, key, location=None):
        location = location or POSTS_LOCATION
        if self.data_storage in ['both', 'file']:
            if location == POSTS_LOCATION:
                return document.settings.bibliographic_fields[key]
            elif location == IMAGES_LOCATION:
                # FIXME: as below
                # Ideally this has been about to be written to a file
                if hasattr(document.settings, 'image_uris'):
                    return document.settings.image_uris[key]
                if self.data_storage == 'file':
                    raise ValueError, "uh oh.. don't know what the image URI should be for {uri}".format(uri=key)

        return self.search_configs(location(self), section, key)

    def has_info(self, document, section, key, location=None):
        location = location or POSTS_LOCATION
        if self.data_storage in ['both', 'file']:
            if location == POSTS_LOCATION:
                return (key in document.settings.bibliographic_fields)
            elif location == IMAGES_LOCATION:
                # FIXME: I don't have a better idea here
                # If you're looking for a URL for an image in the file itself,
                # hopefully it's been saved as saved_as: new_url, but what if
                # the image shows up multiple times? I dunno.
                pass

        class NO_DEFAULT:
            pass

        return self.search_configs(location(self), section, key, NO_DEFAULT) is not NO_DEFAULT


    def replace_field(self, document, key, value):
        keystring = ':{key}:'.format(key=key)
        new_line = '{keystring} {value}'.format(keystring=keystring, value=value)

        lines = self.text.split('\n')
        for i in range(len(lines)):
            if lines[i].strip() == '':
                # Didn't have that field
                lines.insert(i, new_line)
                break
            if lines[i].startswith(keystring):
                lines[i] = new_line
                break

        self.text = '\n'.join(lines)

    def replace_image(self, document, key, value):
        r = re.compile('image::\s+({uri})'.format(uri = re.escape(key)))
        lines = self.text.split('\n')

        for i in range(len(lines)):
            if r.search(lines[i]):
                # FIXME: check indentation or something
                lines.insert(i+1, '   :saved_as: {value}'.format(value=value))

        self.text = '\n'.join(lines)

    def should_save_file(self):
        data_storage = self.config.get('config', 'data_storage')
        save_to_file = data_storage in ['both', 'file']
        return self.text != file(self.filename).read() and save_to_file

    def posts_location(self):
        return os.path.join(BaseDirectory.save_config_path('rst2wp', 'published'),
                            'posts')

    def images_location(self):
        return os.path.join(BaseDirectory.save_config_path('rst2wp', 'published'),
                            'images')


    def run(self, *args, **kwargs):
        if not args: args = sys.argv
        self.parse_args(args)
        config = self.config

        url = config.get('account', 'url')
        username = config.get('account', 'username')
        password = config.get('account', 'password')
        if config.has_option('account', 'verbose'):
            self.VERBOSE = config.get('account', 'verbose')

        print "Connecting to WP server at", url
        wp = wordpresslib.WordPressClient(url, username, password)

        if not config.has_option('account', 'blog_id') or config.get('account', 'blog_id') == '':
            blogs = list(wp.get_users_blogs())
            blog = blogs[0]
            print "Arbitrarily picking first blog: %s at %s"%(blog.name, blog.url)
            wp.selectBlog(blog.id)
        else:
            blog_id = config.get_int('account', 'blog_id')
            print "Using blog id %s from config" % (blog_id,)
            wp.selectBlog(blog_id)

        if self.VERBOSE:
            options = wp.get_options()
            print "Talking to %s version %s"%(options['software_name'], options['software_version'])

        with file(self.filename) as f:
            self.text = text = f.read()
        reader = WordPressReader(self.preview)

        used_images = {}

        output = core.publish_parts(source=text, writer_name='html',
                                    reader=reader,
                                    settings_overrides={
                'wordpress_instance' : wp,
                'application': self,
                'used_images': used_images,
                # FIXME: probably a nicer way to do this
                'filename': self.filename,
                })
        #print yaml.dump(output, default_flow_style=False)
        body = output['body']

        if self.preview:
            return self.run_preview(output)
            

        fields = reader.document.settings.bibliographic_fields

        categories = [wordpresslib.WordPressCategory(name=cat) for cat in fields['categories']]
        tags = []
        for tag in fields['tags']:
            if wp.has_tag(tag):
                tags.append(wp.get_tag(tag))
            else:
                tags.append(wordpresslib.WordPressTag(name=tag))
        new_post_data = {
            'title' : fields['title'],
            'categories': categories,
            'tags': tags,
            'description': body,
            }


        if self.has_info(reader.document, "post " + self.filename, 'id'):
            post_id = self.get_info(reader.document, "post " + self.filename, 'id')
            post = wp.get_post(post_id)

            post.__dict__.update(new_post_data)

            wp.edit_post(post_id, post, False)

        else:
            # FIXME: fields['date']
            user = wp.get_user_info()
            new_post_data['user'] = user.id
            post = wordpresslib.WordPressPost(**new_post_data)

            #post_id = wp.new_post(post, False)
            post_id = '362'
            self.save_info(reader.document, "post " + self.filename,
                           'id', post_id)

        self.save_info(reader.document, "post " + self.filename,
                       'title', fields['title'])

        for image_uri in used_images:
            self.save_info(reader.document, "image " + image_uri,
                           'used in ' + post_id, fields['title'], location=IMAGES_LOCATION)

        if self.should_save_file():
            print "Saving file with new data"
            file(self.filename, 'w').write(self.text)

    def run_preview(self, output):
        body = output['body']
        fp = tempfile.NamedTemporaryFile(suffix='-rst2wp-preview.html',
                                         delete=False)
        fp.write(body)
        fp.close()
        browser = os.getenv('BROWSER') or 'sensible-browser'
        subprocess.call([browser, fp.name])
        # FIXME: better way to know when it gets loaded?
        time.sleep(5)

        os.unlink(fp.name)


POSTS_LOCATION = Rst2Wp.posts_location
IMAGES_LOCATION = Rst2Wp.images_location

if __name__ == '__main__':
    if '--help' in sys.argv:
        print UsageError.usage_message()
        sys.exit(1)

    try:
        Rst2Wp().run()
    except UsageError, u:
        print u.error_message()
        sys.exit(1)
