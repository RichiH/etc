#!/usr/bin/env python

'''Script to translate rst into HTML and post it to a Wordpress server.

This script also has some nice features:

- image:: directives upload images using the WordPress API and point
  at the uploaded URL. If the image is non-local, it will be downloaded using
  urllib and deleted after it's been uploaded.
- categories are read from bibliographic fields at the top of the file.
'''
# FIXME: could save :id: arguments and write new image:: nodes
# FIXME: could store :id and image::s in a separate thing
# FIXME: still need to confirm categories, get new information about them
# FIXME: prompt for a good filename/extension for unknown weird files

# Wordpress Upload Script, etc.
from xdg import BaseDirectory
import ConfigParser
import sys
import os.path
from docutils import core, io, nodes, utils
from docutils.parsers.rst import roles, directives, languages
import docutils.parsers.rst.directives.images
from docutils.readers import standalone
import docutils.transforms
import yaml
import urllib

sys.path.insert(0, os.path.join(os.path.abspath(os.path.dirname(__file__)), "lib"))

TEMP_DIRECTORY = '/tmp'

import wordpresslib

class UsageError(Exception):
    @classmethod
    def usage_message(cls):
        return \
'''Usage: {name} filename
Converts an RST file into HTML and posts it to Wordpress.'''.format(name=os.path.basename(sys.argv[0]))

    def error_message(self):
        return "{error}\nSee '{path} --help'.".format(error=self.args[0],
                                                      path=self.args[1])

class MyImageDirective(directives.images.Image):
    def run(self):
        uri = directives.uri(self.arguments[0])
        print 'Got a call to my image thingy:', uri
        document = self.state_machine.document

        # Call the super here to update options, etc.
        result_nodes = directives.images.Image.run(self)

        # Use a pending to do stuff here -- download after all the
        # checking is done
        pending = nodes.pending(DownloadImageTransform, rawsource=self.block_text)
        pending.details.update(self.options)
        document.note_pending(pending)

        # This could be any inline element, but we use the image we'd
        # normally have to look coherent.
        last_node = result_nodes[-1]
        if isinstance(last_node, nodes.reference):
            last_node = last_node.children[0]

        # Embed the pending in the image node
        last_node += pending
        return result_nodes

directives.register_directive('image', MyImageDirective)

class DownloadImageTransform(docutils.transforms.Transform):
    default_priority = 100
    def apply(self, **kwargs):
        contents = self.build_downloaded_node()
        if self.startnode.parent:
            self.startnode.parent.replace_self(contents)

    def build_downloaded_node(self):
        # FIXME: disabling for now
        return nodes.image(uri=self.startnode.details['uri'])

        filename = uri = self.startnode.details['uri']

        # FIXME: this might not work on non-Unix -- but who cares?
        target_filename = os.path.split(uri)[1]
        if '.' not in target_filename:
            raise TypeError, 'FIXME: prompt for a filename for %s'%(target_filename,)
        #print "returned:", filename, headers

        filename, headers = urllib.urlretrieve(uri, os.path.join(TEMP_DIRECTORY, target_filename))
        wp = self.document.settings.wordpress_instance

        new_uri = wp.upload_file(filename, overwrite=True)

        app = self.document.settings.application
        app.save_info(self.document, 'image urls', uri, new_uri, IMAGES_LOCATION)


        image = nodes.image(uri=new_uri)
        if filename.startswith(TEMP_DIRECTORY):
            # FIXME?
            os.path.unlink(filename)
        return image

class BibliographicTransform(docutils.transforms.Transform):
    '''Parses the crap out of the bibliographic fields in the document
    and sticks them in document.settings.bibliographic_fields.'''
    default_priority = 98
    def __init__(self, *args, **kwargs):
        docutils.transforms.Transform.__init__(self, *args, **kwargs)

    def apply(self, **kwargs):
        header = self.document[0]
        if not isinstance(header, nodes.field_list):
            raise TypeError, "Document did not start with a header"

        fields = self.get_header_as_dict(header)
        self.document.settings.bibliographic_fields = fields

    def get_header_as_dict(self, header):
        fields = {}
        for field in header.children:
            field_name, field_body = field.children

            # field_name is a node with a Text child
            assert len(field_name.children) == 1, "don't know how to handle"
            assert isinstance(field_name.children[0], nodes.Text)
            key = field_name.children[0].astext()

            # field_body is a node with either a bulleted_list child, or
            # a single Text child, or..?
            if len(field_body.children) == 0:
                fields[key] = None
                continue

            assert len(field_body.children) == 1, "don't know how to handle"
            data = field_body.children[0]
            if isinstance(data, nodes.bullet_list):
                value = [node.astext() for node in data.children]
            elif isinstance(data, nodes.Text):
                value = data.astext()
            elif isinstance(data, nodes.paragraph):
                value = data.children[0].astext()
            else:
                raise TypeError, "don't know how to handle a %s in the header %s"%(
                    data.__class__, key)
            fields[key] = value

        return fields

class ValidityCheckerTransform(docutils.transforms.Transform):
    default_priority = 99
    def apply(self):
        fields = self.document.settings.bibliographic_fields
        if 'category' in fields:
            fields['categories'] = fields.pop('category')

        if 'categories' not in fields:
            raise TypeError, "No categories supplied"

        if 'title' not in fields:
            raise TypeError, "title missing"

        categories = fields.get('categories') or fields.get('category')
        wp = self.document.settings.wordpress_instance
        for cat in categories:
            self.check_existing_category(wp, cat)

    def check_existing_category(self, wp, cat):
        if not wp.has_category(cat):
            raise ValueError, "FIXME: prompt for confirmation"


class WordPressReader(standalone.Reader):
    def get_transforms(self):
        transforms = standalone.Reader.get_transforms(self)
        transforms.insert(0, BibliographicTransform)
        transforms.insert(1, ValidityCheckerTransform)
        return transforms


class Application(object):
    def __init__(self):
        super(Application, self).__init__()
        self._config = None

    @property
    def config(self):
        if self._config: return self._config
        return self._load_config()

    def _load_config(self):
        config = ConfigParser.SafeConfigParser()
        self.VERBOSE = False

        for dir in BaseDirectory.load_config_paths('etc-extended'):
            filename = os.path.join(dir, 'wordpressrc')
            if not os.path.exists(filename): continue
            print "loading config from", filename
            with file(filename) as f:
                config.readfp(f)
            print 'config loaded'

        DEFAULT_WORDPRESS_URL = 'http://wordpress.example.com/wordpress/xmlrpc.php'

        if not config.has_section('account'):
            config.add_section('account')
            # Fill in some default values
            config.set('account', 'url', DEFAULT_WORDPRESS_URL)
            config.set('account', 'username', 'joe_user')
            config.set('account', 'password', 'trustNo1')

            path = os.path.join(BaseDirectory.save_config_path('etc-extended'), 'wordpressrc')
            print 'Need configuration! Edit %s'%(path,)
            with file(path, 'wb') as fp:
                config.write(fp)
            sys.exit()

        if config.get('account', 'url') == DEFAULT_WORDPRESS_URL:
            # Don't wipe out what they might have configured
            print 'Still needs configuration! Edit %s'%(path,)
            sys.exit()

        self._config = config
        return config

class Rst2Wp(Application):
    def parse_args(self, args):
        filename = None
        if len(args) > 1:
            filename = args[1]
        if filename == None:
            raise UsageError, ("%s needs a filename."%(args[0],), args[0])

        self.filename = filename

    def prompt(self, msg):
        return raw_input(msg)

    def save_info(self, document, section, key, value, location=None):
        "Usage: app.save_info(document, 'post ' + filename, 'id', '365')"
        location = location or POSTS_LOCATION
        print "saving", key, "=", value, "for document", document.settings.filename


    def posts_location(self):
        return os.path.join(BaseDirectory.save_config_path('rst2wp', 'published'),
                            'posts')

    def images_location(self):
        return os.path.join(BaseDirectory.save_config_path('rst2wp', 'published'),
                            'images')



    def run(self, *args, **kwargs):
        if not args: args = sys.argv
        self.parse_args(args)
        config = self.config

        url = config.get('account', 'url')
        username = config.get('account', 'username')
        password = config.get('account', 'password')
        if config.has_option('account', 'verbose'):
            self.VERBOSE = config.get('account', 'verbose')

        print "Connecting to WP server at", url
        wp = wordpresslib.WordPressClient(url, username, password)

        if not config.has_option('account', 'blog_id') or config.get('account', 'blog_id') == '':
            blogs = list(wp.get_users_blogs())
            blog = blogs[0]
            print "Arbitrarily picking first blog: %s at %s"%(blog.name, blog.url)
            wp.selectBlog(blog.id)
        else:
            blog_id = config.get_int('account', 'blog_id')
            print "Using blog id %s from config" % (blog_id,)
            wp.selectBlog(blog_id)

        if self.VERBOSE:
            options = wp.get_options()
            print "Talking to %s version %s"%(options['software_name'], options['software_version'])

        with file(self.filename) as f:
            text = f.read()
        reader = WordPressReader()

        output = core.publish_parts(source=text, writer_name='html',
                                    reader=reader,
                                    settings_overrides={
                'wordpress_instance' : wp,
                'application': self,
                # FIXME: probably a nicer way to do this
                'filename': self.filename,
                })
        #print yaml.dump(output, default_flow_style=False)
        body = output['body']
        fields = reader.document.settings.bibliographic_fields
        # FIXME: fields['date']

        categories = [wordpresslib.WordPressCategory(name=cat) for cat in fields['categories']]
        new_post_data = {
            'title' : fields['title'],
            'categories': categories,
            'description': body,
            }


        if 'id' in fields:
            post_id = int(fields['id'])
            post = wp.get_post(post_id)

            post.__dict__.update(new_post_data)

            wp.edit_post(post_id, post, False)

        else:
            user = wp.get_user_info()
            new_post_data['user'] = user.id
            post = wordpresslib.WordPressPost(**new_post_data)

            #id = wp.new_post(post, False)
            id = 346
            self.save_info(reader.document, "post " + self.filename,
                           'id', id)
        #sys.exit(0)




        #print wp._server, wp._server.system.listMethods(), wp.supportedMethods()
        #print wp._server.mt.getPostCategories(346, username, password)
        #print wp._server.system.methodSignature('mt.getPostCategories')
        #print list(wp.get_recent_posts())[0].__dict__
        post = wp.get_recent_posts().next()
        post.categories = [wordpresslib.WordPressCategory(name=name) for name in ['future', 'quality Apple hardware', 'oh, Japan!']]
        #print wp.editPost(post.id, post, False)
        #print list(wp.get_recent_posts())[2].categories
        #print wp.upload_file('/home/ethan/software/wordpresslib/python.jpg')
        #print wp.get_categories()[7].description
        #post.categories.extend([31, 3])
        #wp.edit_post(post.id, post, False)

        #wp.getPostCategories(post.id)

POSTS_LOCATION = Rst2Wp.posts_location
IMAGES_LOCATION = Rst2Wp.images_location

if __name__ == '__main__':
    if '--help' in sys.argv:
        print UsageError.usage_message()
        sys.exit(1)

    try:
        Rst2Wp().run()
    except UsageError, u:
        print u.error_message()
        sys.exit(1)
